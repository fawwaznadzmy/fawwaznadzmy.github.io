<!DOCTYPE html>
<html lang="en-US">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta charset="utf-8">
    <title>State Machine Design Pattern in Embedded System - Fawwaz Nadzmy</title>
    <link rel="stylesheet" href="http://localhost:4000/assets/css/styles.css">
 
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

        <!-- highlight.js  -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/github-dark-dimmed.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

    <!-- MathJax -->
    <script>
     MathJax = {
     tex: {
       inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
     };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>
  <body class="">
    <main>
      

 
      <div class="container-fluid">
  <div class="row">
    <!-- Sticky Sidebar TOC -->
    <nav class="col-md-3 d-none d-md-block bg-light" style="min-height: 100vh;">
      <div class="position-sticky" style="top: 80px;">
        <header class="d-flex align-items-center pb-1 mb-2 border-bottom bg-light">
  <a href="/" class="d-flex mx-auto p-4 py-md-1 consolas-font fw-bold align-self-baseline hover text-decoration-none" style="font-size: 19px;">
    <div class="text-info">FawwazNadzmy</div>
    <div class="fw-bold">.</div>
    <div class="logo-color">_</div>
  </a>
</header>
        <div class="pt-3">
          <ul id="toc" class="section-nav">
<li class="toc-entry toc-h3"><a href="#overview">Overview</a></li>
<li class="toc-entry toc-h3"><a href="#state-machine-design">State machine design</a></li>
<li class="toc-entry toc-h3">
<a href="#state-machine-implementation">State machine implementation</a>
<ul>
<li class="toc-entry toc-h4"><a href="#1-switch-case-method">1. Switch-case method</a></li>
<li class="toc-entry toc-h4"><a href="#2-function-pointer-method">2. Function pointer method</a></li>
<li class="toc-entry toc-h4"><a href="#3-lookup-table-method">3. Lookup table method</a></li>
<li class="toc-entry toc-h4"><a href="#4-object-oriented-method">4. Object-oriented method</a></li>
</ul>
</li>
</ul>
        </div>
        <!-- Related Blog Posts -->
        <div class="pt-4">
          <h6 class="fw-bold">Related Posts</h6>
          <ul class="list-unstyled">
            
              <li class="mb-2 text-muted">No related posts found.</li>
            
          </ul>
        </div>
      </div>
    </nav>
    <!-- Main Content -->
    <main class="mx-auto" style="max-width: 750px;">
      <div class="pt-5 mb-1 rounded-3">
        <h1 class="fw-bold">State Machine Design Pattern in Embedded System</h1>
      </div>
      <div class="mb-3 text-muted">
        <i class="fa fa-calendar"></i>
        March 26, 2024
        
        
      </div>
      <div>
        <h3 id="overview">Overview</h3>
<p>A state machine consists of <code class="language-plaintext highlighter-rouge">States</code> , <code class="language-plaintext highlighter-rouge">Events</code>, <code class="language-plaintext highlighter-rouge">Action</code> and <code class="language-plaintext highlighter-rouge">Transitions</code>. 
A state is a condition or mode of operation that the system can be in.</p>
<ul>
  <li>An event is a stimulus or trigger that causes the system to change its state.</li>
  <li>A transition is a rule or action that defines how the system moves from one state to another.</li>
  <li>A state machine can only be in one state at a time, and it can only change its state when an event occurs.</li>
</ul>

<h3 id="state-machine-design">State machine design</h3>
<p>To design a state machine, you need to identify the states, events, and transitions that are relevant to your system. You can use diagrams, tables, or pseudocode to represent your state machine. A common diagramming method is the state transition diagram, which shows the states as circles, the events as arrows, and the transitions as labels on the arrows. A common tabular method is the state transition table, which shows the states as rows, the events as columns, and the transitions as cells. A common pseudocode method is the state transition list, which shows the states as cases, the events as conditions, and the transitions as statements.</p>

<h3 id="state-machine-implementation">State machine implementation</h3>
<p>To implement a state machine in an embedded system, you need to choose a method that suits your programming language, hardware, and requirements. There are several methods to implement a state machine, such as switch-case statements, function pointers, lookup tables, or object-oriented classes. Each method has its advantages and disadvantages in terms of readability, maintainability, performance, and memory usage. You should compare the different methods and select the one that best fits your needs.</p>

<h4 id="1-switch-case-method">1. Switch-case method</h4>
<p>The switch-case method is a simple and intuitive way to implement a state machine. It uses a switch-case statement to execute different code blocks based on the current state and the incoming event. The switch-case statement can be nested or sequential, depending on the complexity of the state machine.</p>

<p><span class="fw-bold" style="color:blue">Advantages:</span></p>
<ul>
  <li>The switch-case method is easy to understand and modify,</li>
</ul>

<p><span class="fw-bold text-info">Disadvantages:</span>.</p>
<ul>
  <li>it can become cumbersome and error-prone if the state machine has many states and events.</li>
</ul>

<h4 id="2-function-pointer-method">2. Function pointer method</h4>
<p>The function pointer method is a more advanced and flexible way to implement a state machine. It uses an array of function pointers to store the addresses of the functions that handle each state and event.</p>

<p><span class="fw-bold" style="color:blue">Advantages:</span></p>
<ul>
  <li>The function pointer method can reduce the code size and complexity by avoiding nested or repeated switch-case statements.</li>
</ul>

<p><span class="fw-bold text-info">Disadvantages:</span>.</p>
<ul>
  <li>However, the function pointer method can be harder to debug and test,</li>
  <li>It can introduce some overhead in terms of memory and execution time.</li>
</ul>

<h4 id="3-lookup-table-method">3. Lookup table method</h4>
<p>The lookup table method is a fast and efficient way to implement a state machine. It uses a two-dimensional array to store the next state and the transition function for each state and event combination. The lookup table method can eliminate the need for switch-case statements or function pointers, and it can speed up the state machine execution by using direct indexing. However, the lookup table method can consume a lot of memory, and it can be difficult to maintain and update the table.</p>

<h4 id="4-object-oriented-method">4. Object-oriented method</h4>
<p>The object-oriented method is a modular and reusable way to implement a state machine. It uses classes and inheritance to represent the states and the transitions as objects. The object-oriented method can encapsulate the state machine logic and behavior in a single class, and it can allow multiple instances of the state machine to run simultaneously. However, the object-oriented method can be more complex and verbose, and it can require more memory and processing power.</p>


      </div>
    </main>
  </div>
</div>

<!-- Smooth scroll for TOC links -->
<script>
document.addEventListener('DOMContentLoaded', function() {
  document.querySelectorAll('nav .toc-entry a').forEach(function(link) {
    link.addEventListener('click', function(e) {
      const targetId = this.getAttribute('href').replace('#', '');
      const target = document.getElementById(targetId);
      if (target) {
        e.preventDefault();
        window.scrollTo({
          top: target.getBoundingClientRect().top + window.scrollY - 70,
          behavior: 'smooth'
        });
        history.replaceState(null, null, '#' + targetId);
      }
    });
  });
});
</script>





  </main>
  <footer class="footer border-top bg-light">
<div class="d-flex justify-content-center text-body-secondary pt-3">
    Fawwaz Nadzmy · © 2024
</div>
<div class="d-flex justify-content-center p-3">
    <a href="" class="btn btn-lg shadow-sm  fa fa-google m-1" role="button"></a>
    <a href="https://github.com/" class="btn btn-lg  shadow-sm fa fa-github m-1" role="button" rel="external nofollow noopener" target="_blank"></a>
    <a href="https://linkedin.com/" class="btn btn-lg  shadow-sm  fa fa-linkedin m-1" role="button" rel="external nofollow noopener" target="_blank"></a>
</div> 
</footer>
  </body>

</html>
