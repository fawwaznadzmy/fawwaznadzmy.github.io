<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-06-28T14:47:01+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Fawwaz Nadzmy</title><entry><title type="html">Dependency Injection in C++</title><link href="http://localhost:4000/blog/2024/05/08/Dependency-injection.html" rel="alternate" type="text/html" title="Dependency Injection in C++" /><published>2024-05-08T18:40:16+08:00</published><updated>2024-05-08T18:40:16+08:00</updated><id>http://localhost:4000/blog/2024/05/08/Dependency-injection</id><content type="html" xml:base="http://localhost:4000/blog/2024/05/08/Dependency-injection.html"><![CDATA[<p>In this post, I will switch gears from functional C++ to object oriented C++ and talk about dependency injection.</p>

<p>Let’s start with a simple example: take a Car class with a Drive() method. Let’s say this class contains a V8Engine attribute with Start() and Stop() methods. An initial implementation might look like this:</p>

<p>V8Engine.h (publicly visible):</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma once
</span>
<span class="k">class</span> <span class="nc">V8Engine</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div>
<p>V8Engine.cpp:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"V8Engine.h"</span><span class="cp">
</span>
<span class="n">V8Engine</span><span class="o">::</span><span class="n">Start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// start the engine</span>
<span class="p">}</span>

<span class="n">V8Engine</span><span class="o">::</span><span class="n">Stop</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// stop the engine</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Car.h (publicly visible):</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma once
#include</span> <span class="cpf">"V8Engine.h"</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Car</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">Drive</span><span class="p">();</span>

<span class="nl">private:</span>
    <span class="n">V8Engine</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Car.cpp:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp">
</span>
<span class="kt">void</span> <span class="n">Car</span><span class="o">::</span><span class="n">Drive</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
    <span class="c1">// drive</span>
    <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
<span class="p">}</span>

</code></pre></div></div>
<h3 id="dependency-injection-with-interfaces">Dependency Injection with Interfaces</h3>
<p>In the above example, Car is tightly coupled to V8Engine, meaning we can’t create a car without a concrete engine implementation. If we want the ability to swap various engines or use a mock engine during testing, we could reverse the dependency by creating an IEngine interface and decoupling Car from the concrete V8Engine implementation. This way, we only expose an IEngine interface and a factory function. Car can work against that:</p>

<p>IEngine.h (publicly visible):</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma once
</span>
<span class="k">struct</span> <span class="nc">IEngine</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">IEngine</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">MakeV8Engine</span><span class="p">();</span>
</code></pre></div></div>
<p>V8Engine.cpp:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"IEngine.h"</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">V8Engine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* start the engine */</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* stop the engine */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">MakeV8Engine</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Car.h (publicly visible):</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma once
#include</span> <span class="cpf">"IEngine.h"</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Car</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">Drive</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<p>Car.cpp:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp">
</span>
<span class="kt">void</span> <span class="n">Car</span><span class="o">::</span><span class="n">Drive</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">();</span>
    <span class="c1">// drive</span>
    <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">End</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Note</strong>
A note on headers
Headers simply get textually included in each compilation unit by the #include directive. It is not mandatory to provide a header file for each class declaration. If a class can be scoped to a single source file, then it doesn’t need a header declaration (for example the V8Engine class above does not need a V8Engine.h header corresponding to the V8Engine.cpp). It is also a good idea to have public headers and internal headers: public headers contain the public API surface and can be included by other parts of the system, while internal headers are only used within the component and should not be included by external code.</p>

<p>Default should be the least visible: try to keep everything inside the cpp file (like V8Engine.cpp). If that is not enough, an internal header might do. A declaration should be pulled into a public header only when external components need to reference it.</p>

<p><strong>A note on Interface</strong>
It’s a good idea to declare a default virtual destructor: if a deriving type has a destructor, it won’t get called if we store an upcast pointer to the interface unless the interface declares a virtual destructor. Note a destructor does not to be expicitly defined - compiler might generate a default one.</p>

<p>MSVC compiler provides a __declspec(novtable)1 custom attribute which tells the compiler not to generate a vtable for pure abstract classes. This reduces code size. Below is the IEngine declaration with this attribute:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">__declspec</span><span class="p">(</span><span class="n">novtable</span><span class="p">)</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">IEngine</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<p>I won’t include it in the code samples in this post, but it’s worth keeping in mind when working with MSVC.</p>

<p><strong><em>A note on factory functions</em></strong>
When working with interfaces as opposed to concrete types, we use factory functions to get object instances. Below is a possible naming convention, taking object ownership into account:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IFoo</span><span class="o">&gt;</span> <span class="n">MakeFoo</span><span class="p">();</span>
<span class="n">IFoo</span><span class="o">&amp;</span> <span class="n">UseFoo</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">IFoo</span><span class="o">&gt;</span> <span class="n">GetFoo</span><span class="p">();</span>
</code></pre></div></div>
<p>The first function, MakeFoo, returns a unique pointer, passing ownership to the caller. Like in the example above, the <code class="language-plaintext highlighter-rouge">unqiue_ptr</code> can be moved into the object, which ends up owning it. Use a Make when each call creates a new instance.</p>

<p>The second function implies there already exists an IFoo object which is owned by someone else, with the guarantee that it will outlive the caller. In that case, there is no need for pointers and we can simply return a reference to the object. This can be used, for example, for singletons. Below is an example of a singleton Engine:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">IEngine</span><span class="o">&amp;</span> <span class="n">UseEngine</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Engine</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The third function, GetFoo, implies shared ownership - we get an object that other objects might hold a reference to, but we don’t have the lifetime guarantee a singleton would give us, so we need to use a shared pointer to make sure the object is kept alive long enough.</p>

<p><strong>Mocking</strong>
Since Car now works with an IEngine interface, in test code we can mock the engine:</p>

<p>Test.cpp:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">MockEngine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Car</span> <span class="n">car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MockEngine</span><span class="o">&gt;</span><span class="p">());</span>

    <span class="c1">// Test Car without a real Engine</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can also expose Car as a simple interface, hiding its implementation details, in which case we would end up with the following:</p>

<p>ICar.h (publicly visible):</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma once
#include</span> <span class="cpf">"IEngine.h"</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">ICar</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ICar</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="n">engine</span><span class="p">);</span>
</code></pre></div></div>
<p>Car.cpp:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"ICar.h"</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ICar</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
         <span class="o">:</span> <span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">Drive</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">();</span>
         <span class="c1">// drive</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Test would become:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"ICar.h"</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">MockEngine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">car</span> <span class="o">=</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MockEngine</span><span class="o">&gt;</span><span class="p">());</span>

    <span class="c1">// Test ICar without a real Engine</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Note this allows the caller to pass in any IEngine. We provide an out-of-the-box V8Engine but other engines can be injected when Car gets constructed. The headers IEngine.h and ICar.h are public per our above definition.</p>

<p>In general, it’s great if we can get the rest of the component code and unit tests to work against the interface. Sometimes though we might need to know more about the actual implementation inside our component, even if externally we only expose an interface. In that case, we can add an internal Car.h header:</p>

<p>Car.h (internal):</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma once
#include</span> <span class="cpf">"ICar.h"</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ICar</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
         <span class="o">:</span> <span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<p>Car.cpp becomes:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp">
</span>
<span class="kt">void</span> <span class="n">Car</span><span class="o">::</span><span class="n">Drive</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
    <span class="c1">// drive</span>
    <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">));</span>
<span class="p">}</span>

</code></pre></div></div>
<p>Now we can include the internal header, and, while not necessarily recommended, we can cast ICar to Car inside the component:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">icar</span> <span class="o">=</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">MakeV8Engine</span><span class="p">());</span>
<span class="k">auto</span><span class="o">&amp;</span> <span class="n">car</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">car</span><span class="p">);</span>
</code></pre></div></div>

<p>Another trick if needing access to internals (again, not something necessarily recommended), is to make the unit test class testing Car a friend of the Car class, in which case it can access its private members.</p>

<p>In summary, with this approach we are able to:</p>

<ul>
  <li>Hide implementation details in the .cpp files</li>
  <li>Work against abstract interfaces</li>
  <li>Inject dependencies during object construction</li>
</ul>

<h3 id="dependency-injection-with-templates">Dependency Injection with Templates</h3>
<p>An alternative to the above is to use templates. In this case, we would have to provide the implementation inside the header file, as code needs to be available when templates get instantiated:</p>

<p>V8Engine.h (publicly visible):</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma once
</span>
<span class="k">class</span> <span class="nc">V8Engine</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div>
<p>V8Engine.cpp:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"V8Engine.h"</span><span class="cp">
</span>
<span class="n">V8Engine</span><span class="o">::</span><span class="n">Start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// start the engine</span>
<span class="p">}</span>

<span class="n">V8Engine</span><span class="o">::</span><span class="n">Stop</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// stop the engine</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Car.h (publicly visible):</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma once
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">TEngine</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Car</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
        <span class="c1">// drive</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">TEngine</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<p>Note Car is implemented in the header and V8Engine is also a publicly visible header. Now we can create an instance of Car like this:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"V8Engine.h"</span><span class="cp">
#include</span> <span class="cpf">"Car.h"</span><span class="cp">
</span>

<span class="n">Car</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;</span> <span class="n">car</span><span class="p">;</span>
</code></pre></div></div>
<p>Mocking the engine in test code would look like this:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">MockEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">Stop</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Car</span><span class="o">&lt;</span><span class="n">MockEngine</span><span class="o">&gt;</span> <span class="n">car</span><span class="p">;</span>

    <span class="c1">// Test Car without a real Engine</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With this approach we are able to:</p>

<ul>
  <li>Inject dependencies during template instantiation</li>
  <li>No need for virtual calls (note TEngine is not an interface, so calls can be resolved at compile-time)</li>
  <li>Car<T> can be default-constructed</T></li>
</ul>

<p>A drawback here is we expose the implementation details of Car inside the header file and we have to make this publicly visible.</p>

<h3 id="hybrid-approach">Hybrid Approach</h3>
<p>We can use a hybrid approach if we don’t need an externally injected Engine. Say our component provides a V8Engine, a V6Engine, and we have a MockEngine used during testing. We have the same componentization requirements but don’t need to expose all the details to consumers. In that case we could have something like this:</p>

<p>ICar.h (publicly visible):</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">##pragma once
</span>
<span class="k">struct</span> <span class="nc">ICar</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ICar</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeV8Car</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeV6Car</span><span class="p">();</span>
</code></pre></div></div>

<p>Car.h (internal):</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma once
#include</span> <span class="cpf">"ICar.h"</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">TEngine</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ICar</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
        <span class="c1">// drive</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">TEngine</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<p>Car.cpp:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp">
#include</span> <span class="cpf">"V8Engine.h"</span><span class="cp">
#include</span> <span class="cpf">"V6Engine.h"</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeV8Car</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;&gt;</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeV6Car</span><span class="p">();</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&lt;</span><span class="n">V6Engine</span><span class="o">&gt;&gt;</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Test would remain the same as in the example above, where we worked against a Car type (not an ICar) which we instantiate with a MockEngine.</p>

<p>With this approach:</p>

<ul>
  <li>Our external API is an interface</li>
  <li>Internally we still inject the dependency using a template
With this approach, we do have an interface and virtual calls for Car but not for TEngine types. One drawback with this approach is that consumers cannot inject their own Engine type: we can only create cars with engines that are known within our component.</li>
</ul>

<p><strong>Summary</strong>
We decoupled Car from V8Engine and looked at three ways of injecting the dependency:</p>

<ul>
  <li>Using interfaces, where dependency is injected at runtime during object creation</li>
  <li>Using templates, where dependency is injected at compile-time during template instantiation</li>
  <li>A hybrid approach which uses templates internally but exposes only interfaces publicly</li>
</ul>

<p>Each of these approaches has pros and cons, the tradeoffs mostly being around encapsulation (how much of the component code we expose publicly), runtime (templates are instantiated at compile-time so no virtual calls etc.), type constraints (with templates we don’t require engines to implement a particular IEngine interface), and flexibility (with the hybrid approach we can’t inject an external engine, we can only use what the component has available internally).</p>]]></content><author><name></name></author><category term="blog" /><category term="formatting" /><category term="links" /><summary type="html"><![CDATA[Overview of state machine strategy in approaching embedded software design.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/img/image2.png" /><media:content medium="image" url="http://localhost:4000/assets/img/image2.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Fundamental of Test Driven Design (TDD)</title><link href="http://localhost:4000/blog/2024/03/26/Fundemantal_of_TDD.html" rel="alternate" type="text/html" title="Fundamental of Test Driven Design (TDD)" /><published>2024-03-26T18:40:16+08:00</published><updated>2024-03-26T18:40:16+08:00</updated><id>http://localhost:4000/blog/2024/03/26/Fundemantal_of_TDD</id><content type="html" xml:base="http://localhost:4000/blog/2024/03/26/Fundemantal_of_TDD.html"><![CDATA[<h1 id="overview">Overview</h1>
<h3 id="code-smell">Code Smell</h3>]]></content><author><name></name></author><category term="blog" /><category term="formatting" /><category term="links" /><summary type="html"><![CDATA[Provide fundamental of Test Driven Design in software development]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/img/image2.png" /><media:content medium="image" url="http://localhost:4000/assets/img/image2.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Micro in C++</title><link href="http://localhost:4000/blog/2024/03/26/Micro-in-C++.html" rel="alternate" type="text/html" title="Micro in C++" /><published>2024-03-26T18:40:16+08:00</published><updated>2024-03-26T18:40:16+08:00</updated><id>http://localhost:4000/blog/2024/03/26/Micro-in-C++</id><content type="html" xml:base="http://localhost:4000/blog/2024/03/26/Micro-in-C++.html"><![CDATA[]]></content><author><name></name></author><category term="blog" /><category term="formatting" /><category term="links" /><summary type="html"><![CDATA[Overview of state machine strategy in approaching embedded software design.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/img/image2.png" /><media:content medium="image" url="http://localhost:4000/assets/img/image2.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">State Machine Design Pattern in Embedded System</title><link href="http://localhost:4000/blog/2024/03/26/State-Machine.html" rel="alternate" type="text/html" title="State Machine Design Pattern in Embedded System" /><published>2024-03-26T18:40:16+08:00</published><updated>2024-03-26T18:40:16+08:00</updated><id>http://localhost:4000/blog/2024/03/26/State-Machine</id><content type="html" xml:base="http://localhost:4000/blog/2024/03/26/State-Machine.html"><![CDATA[<h3 id="overview">Overview</h3>
<p>A state machine consists of <code class="language-plaintext highlighter-rouge">States</code> , <code class="language-plaintext highlighter-rouge">Events</code>, <code class="language-plaintext highlighter-rouge">Action</code> and <code class="language-plaintext highlighter-rouge">Transitions</code>. 
A state is a condition or mode of operation that the system can be in.</p>
<ul>
  <li>An event is a stimulus or trigger that causes the system to change its state.</li>
  <li>A transition is a rule or action that defines how the system moves from one state to another.</li>
  <li>A state machine can only be in one state at a time, and it can only change its state when an event occurs.</li>
</ul>

<h3 id="state-machine-design">State machine design</h3>
<p>To design a state machine, you need to identify the states, events, and transitions that are relevant to your system. You can use diagrams, tables, or pseudocode to represent your state machine. A common diagramming method is the state transition diagram, which shows the states as circles, the events as arrows, and the transitions as labels on the arrows. A common tabular method is the state transition table, which shows the states as rows, the events as columns, and the transitions as cells. A common pseudocode method is the state transition list, which shows the states as cases, the events as conditions, and the transitions as statements.</p>

<h3 id="state-machine-implementation">State machine implementation</h3>
<p>To implement a state machine in an embedded system, you need to choose a method that suits your programming language, hardware, and requirements. There are several methods to implement a state machine, such as switch-case statements, function pointers, lookup tables, or object-oriented classes. Each method has its advantages and disadvantages in terms of readability, maintainability, performance, and memory usage. You should compare the different methods and select the one that best fits your needs.</p>

<h4 id="1-switch-case-method">1. Switch-case method</h4>
<p>The switch-case method is a simple and intuitive way to implement a state machine. It uses a switch-case statement to execute different code blocks based on the current state and the incoming event. The switch-case statement can be nested or sequential, depending on the complexity of the state machine.</p>

<p><span class="fw-bold" style="color:blue">Advantages:</span></p>
<ul>
  <li>The switch-case method is easy to understand and modify,</li>
</ul>

<p><span class="fw-bold text-info">Disadvantages:</span>.</p>
<ul>
  <li>it can become cumbersome and error-prone if the state machine has many states and events.</li>
</ul>

<h4 id="2-function-pointer-method">2. Function pointer method</h4>
<p>The function pointer method is a more advanced and flexible way to implement a state machine. It uses an array of function pointers to store the addresses of the functions that handle each state and event.</p>

<p><span class="fw-bold" style="color:blue">Advantages:</span></p>
<ul>
  <li>The function pointer method can reduce the code size and complexity by avoiding nested or repeated switch-case statements.</li>
</ul>

<p><span class="fw-bold text-info">Disadvantages:</span>.</p>
<ul>
  <li>However, the function pointer method can be harder to debug and test,</li>
  <li>It can introduce some overhead in terms of memory and execution time.</li>
</ul>

<h4 id="3-lookup-table-method">3. Lookup table method</h4>
<p>The lookup table method is a fast and efficient way to implement a state machine. It uses a two-dimensional array to store the next state and the transition function for each state and event combination. The lookup table method can eliminate the need for switch-case statements or function pointers, and it can speed up the state machine execution by using direct indexing. However, the lookup table method can consume a lot of memory, and it can be difficult to maintain and update the table.</p>

<h4 id="4-object-oriented-method">4. Object-oriented method</h4>
<p>The object-oriented method is a modular and reusable way to implement a state machine. It uses classes and inheritance to represent the states and the transitions as objects. The object-oriented method can encapsulate the state machine logic and behavior in a single class, and it can allow multiple instances of the state machine to run simultaneously. However, the object-oriented method can be more complex and verbose, and it can require more memory and processing power.</p>]]></content><author><name></name></author><category term="blog" /><category term="formatting" /><category term="links" /><summary type="html"><![CDATA[Overview of state machine strategy in approaching embedded software design.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/img/image2.png" /><media:content medium="image" url="http://localhost:4000/assets/img/image2.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Jupyter Notebook Essential</title><link href="http://localhost:4000/blog/2024/03/26/Jupyter-notebook-essential.html" rel="alternate" type="text/html" title="Jupyter Notebook Essential" /><published>2024-03-26T18:40:16+08:00</published><updated>2024-03-26T18:40:16+08:00</updated><id>http://localhost:4000/blog/2024/03/26/Jupyter-notebook%20essential</id><content type="html" xml:base="http://localhost:4000/blog/2024/03/26/Jupyter-notebook-essential.html"><![CDATA[<h3 id="installing-jupyter-notebook">Installing Jupyter Notebook</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip install jupyterlab
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jupyter notebook
</code></pre></div></div>

<p>Started jupyter server in local machine in port 8888 with <code class="language-plaintext highlighter-rouge">http://127.0.0.1:8888</code> can be accessed through web browser.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jupyter lab
</code></pre></div></div>

<h4 id="keyboard-shortcut">Keyboard shortcut</h4>

<table>
  <thead>
    <tr>
      <th>Key</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[shift] + [enter]</td>
      <td>RUN and go to next cell</td>
    </tr>
    <tr>
      <td>[ctrl]  + [enter]</td>
      <td>RUN and stay in same cell</td>
    </tr>
    <tr>
      <td>[ESC]</td>
      <td>Get out from the cell</td>
    </tr>
    <tr>
      <td>[J] or [K]</td>
      <td>Move from cell to cell</td>
    </tr>
    <tr>
      <td>[A]</td>
      <td>Add cell above</td>
    </tr>
    <tr>
      <td>[B]</td>
      <td>Add cell below</td>
    </tr>
    <tr>
      <td>[D] then [D]</td>
      <td>Delete cell</td>
    </tr>
    <tr>
      <td>[ESC] then [M]</td>
      <td>change to markdown</td>
    </tr>
    <tr>
      <td>[ESC] then [Y]</td>
      <td>change to code</td>
    </tr>
  </tbody>
</table>]]></content><author><name></name></author><category term="blog" /><category term="formatting" /><category term="links" /><summary type="html"><![CDATA[Overview of state machine strategy in approaching embedded software design.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/img/image2.png" /><media:content medium="image" url="http://localhost:4000/assets/img/image2.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Foundation of Software Testing</title><link href="http://localhost:4000/blog/2024/03/26/Foundation-of-Software-Testing.html" rel="alternate" type="text/html" title="Foundation of Software Testing" /><published>2024-03-26T18:40:16+08:00</published><updated>2024-03-26T18:40:16+08:00</updated><id>http://localhost:4000/blog/2024/03/26/Foundation-of-Software-Testing</id><content type="html" xml:base="http://localhost:4000/blog/2024/03/26/Foundation-of-Software-Testing.html"><![CDATA[<p>In this syllabus, the following five test levels are described:
• Component testing (also known as unit testing) focuses on testing components in isolation. It
often requires specific support, such as test harnesses or unit test frameworks. Component
testing is normally performed by developers in their development environments.
• Component integration testing (also known as unit integration testing) focuses on testing the
interfaces and interactions between components. Component integration testing is heavily
dependent on the integration strategy approaches like bottom-up, top-down or big-bang.
• System testing focuses on the overall behavior and capabilities of an entire system or product,
often including functional testing of end-to-end tasks and the non-functional testing of quality
characteristics. For some non-functional quality characteristics, it is preferable to test them on a
complete system in a representative test environment (e.g., usability). Using simulations of sub
systems is also possible. System testing may be performed by an independent test team, and is
related to specifications for the system.
• System integration testing focuses on testing the interfaces of the system under test and other
systems and external services . System integration testing requires suitable test environments
preferably similar to the operational environment.
• Acceptance testing focuses on validation and on demonstrating readiness for deployment,
which means that the system fulfills the user’s business needs. Ideally, acceptance testing should
be performed by the intended users. The main forms of acceptance testing are: user acceptance
testing (UAT), operational acceptance testing, contractual and regulatory acceptance testing,
alpha testing and beta testing</p>

<p>A lot of test types exist and can be applied in projects. In this syllabus, the following four test types are
addressed:
Functional testing evaluates the functions that a component or system should perform. The functions
are “what” the test object should do. The main objective of functional testing is checking the functional
completeness, functional correctness and functional appropriateness.
Non-functional testing evaluates attributes other than functional characteristics of a component or
system. Non-functional testing is the testing of “how well the system behaves”. The main objective of nonfunctional testing is checking the non-functional software quality characteristics. The ISO/IEC 25010
standard provides the following classification of the non-functional software quality characteristics:
• Performance efficiency
• Compatibility
• Usability
• Reliability
• Security
• Maintainability
• Portability</p>

<p>Black-box testing (see section 4.2) is specification-based and derives tests from documentation external
to the test object. The main objective of black-box testing is checking the system’s behavior against its
specifications.
White-box testing (see section 4.3) is structure-based and derives tests from the system’s
implementation or internal structure (e.g., code, architecture, work flows, and data flows). The main
objective of white-box testing is to cover the underlying structure by the tests to the acceptable level</p>]]></content><author><name></name></author><category term="blog" /><category term="formatting" /><category term="links" /><summary type="html"><![CDATA[Overview of state machine strategy in approaching embedded software design.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/img/image2.png" /><media:content medium="image" url="http://localhost:4000/assets/img/image2.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">a post with jupyter notebook</title><link href="http://localhost:4000/portfolio/2023/07/04/jupyter-notebook.html" rel="alternate" type="text/html" title="a post with jupyter notebook" /><published>2023-07-04T20:57:00+08:00</published><updated>2023-07-04T20:57:00+08:00</updated><id>http://localhost:4000/portfolio/2023/07/04/jupyter-notebook</id><content type="html" xml:base="http://localhost:4000/portfolio/2023/07/04/jupyter-notebook.html"><![CDATA[<p>To include a jupyter notebook in a post, you can use the following code:</p>]]></content><author><name></name></author><category term="portfolio" /><category term="formatting" /><category term="jupyter" /><summary type="html"><![CDATA[an example of a blog post with jupyter notebook]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/img/image2.png" /><media:content medium="image" url="http://localhost:4000/assets/img/image2.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">a post with jupyter notebook</title><link href="http://localhost:4000/portfolio/2023/07/04/Medical-Expendeture.html" rel="alternate" type="text/html" title="a post with jupyter notebook" /><published>2023-07-04T20:57:00+08:00</published><updated>2023-07-04T20:57:00+08:00</updated><id>http://localhost:4000/portfolio/2023/07/04/Medical-Expendeture</id><content type="html" xml:base="http://localhost:4000/portfolio/2023/07/04/Medical-Expendeture.html"><![CDATA[<p>To include a jupyter notebook in a post, you can use the following code:</p>]]></content><author><name></name></author><category term="portfolio" /><category term="formatting" /><category term="jupyter" /><summary type="html"><![CDATA[an example of a blog post with jupyter notebook]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/img/image2.png" /><media:content medium="image" url="http://localhost:4000/assets/img/image2.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>